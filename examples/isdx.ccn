typedef uint<32> IP4

typedef struct {
    uint<48> dstAddr,
    uint<48> srcAddr
} eth_t 

typedef struct {
    uint<8> protocol,
    IP4 src,
    IP4 dst
} ip4_t

typedef struct {
    bool valid,
    uint<16> vid
} vlan_t

typedef struct {
    eth_t    eth,
    ip4_t    ip4,
    vlan_t   vlan
} Packet

typedef uint<10> ASId
typedef struct {
    uint<32> addr,
    uint<8>  mask
} IP4Prefix

typedef uint<16> ASPort
typedef uint<16> SDXPort
typedef uint<32> PrefixId

(* 
BGP route database encoding
*)

(* Number of ASs connected to exchange *)
function nAS(): ASId
assume () nAS() <= 10'd48

function iAS(ASId as): bool = as < nAS()


(* Number of SDX-facing ports for each AS *)
function asNPorts(ASId as): ASPort

function iASPort(ASId as, ASPort port): bool = as < nAS() and port < asNPorts(as)

(* Database of routes advertised via BGP *)
function asNPrefixes(ASId as): PrefixId
function asPrefix(ASId as, PrefixId pref): IP4Prefix

(*
User-defined policy functions 
*)
function outbound_policy(ASId as, ip4_t p): ASId

function inbound_policy(ASId as, ip4_t p): ASPort
(* inbound policy must route packets to valid port numbers *)
assume (ASId as, ip4_t p, ASPort port) iAS(as) and (inbound_policy(as, p) == port) => (port < asNPorts(as))

function next_hop(ASId as, IP4 addr): ASId

(* next_hop must be consistent with BGP database *)
assume (ASId as, ASId dst, IP4 ip) 
    (iAS(dst) and (next_hop(as, ip) == dst)) => prefix_match(ip, as)

(* true iff addr matches one of the prefixes *)
function prefix_match(IP4 addr, ASId as): bool

(* TODO: an even more abstract spec *)

role ASRouterIn[ASId as] | iAS(as) = 
    let ASId dst = outbound_policy(as, pkt.ip4);
    let ASId defdst = next_hop(as, pkt.ip4.dst);
    havoc pkt.eth;
    if iAS(dst) and prefix_match(pkt.ip4.dst, dst) then {
        send ASSDXIn[dst, inbound_policy(dst, pkt.ip4)]
    } else if iAS(defdst) then {
        send ASSDXIn[defdst, inbound_policy(defdst, pkt.ip4)]
    }

role ASSDXIn[ASId as, ASPort port] | iASPort(as, port) = filter false


refine ASRouterIn {

    function nSDXPort(): SDXPort
    function iSDXPort(SDXPort port): bool = port < nSDXPort()

    function asSDXLink(ASId as, ASPort asport): SDXPort
    assume (ASId ac, ASPort asport) iASPort(as, asport) => iSDXPort(asSDXLink(as, asport))

    function sdxASLink(SDXPort port): ASPortDescr
    (*assume iSDXPort(sdxport) => iASPort(sdxASLink(sdxport)) *)
    assume iASPort(as, asport) => (ASPortDescr{as, asport} == sdxASLink(asSDXLink(as, asport)))

    function encode(ASId as, List<ASId>): uint<38>
    function decode(ASId as, uint<38>): List<ASId>
    assume(ASId as, List<ASId> rset) iAS(as) => decode(as, encode(as, rset)) == rset

    role ASRouterIn[ASId as] | iAS(as) = 
         let rset = map(fst, filter(bgp_db(),prefix_match(pkt.ip4.dst))) in
         pkt.eth.dstAddr := encode(rset) ++ next_hop(as, pkt.ip4.dst);
         send ASRouterOut[as, 16'd0] 

    role ASRouterOut[ASId as, ASPort port] | iASPort(as, port) = 
         send SDXIn[as_sdx_connection(as, port)]

    role SDXIn[SDXPort port] | iSDXPort(port) = 
        let srcas  = sdx_as_connection(port).as in
        let rset   = decode(pkt.eth.dstAddr[0:37]) in
        let dst    = outbound_policy(srcas, pkt.ip4) in
        let defdst = pkt.eth.dstAddr[38:47] in
        if ((not dst == asnone()) and elem(dst,rset)) then {
            send SDXOut[as_sdx_connection(dst, inbound_policy(dst, pkt.ip4))]
        } else if not defdst == asnone() then {
            send SDXOut[as_sdx_connection(defdst, inbound_policy(defdst, pkt.ip4)]
        }

    role SDXOut[SDXPort port] | iSDXPort(port) = 
        ASSDXIn[sdx_as_connection(port).as, sdx_as_connection(port).port]
}


refine {

    function nAS(): ASId = 10'd48
    function asNPorts(ASId as): ASPort = 16'd1
}
