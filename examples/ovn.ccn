/* OVN (Open Virtual Network) specified using Cocoon  */

/* Q: Do parent port ACLs apply to child ports?
   Q: Are parent port addresses ignored?
   Q: Does parent port enabled status apply to child ports?
 */

typedef port_id_t  = string
typedef mac_addr_t = bit<48>
typedef ip4_addr_t = bit<32>
typedef ip6_addr_t = bit<128>
typedef ip_addr_t  = IPAddr4 {addr4 : ip4_addr_t}
                   | IPAddr6 {addr6 : ip6_addr_t}

typedef Packet = eth_pkt_t

typedef eth_pkt_t = EtherPacket { src  : mac_addr_t
                                , dst  : mac_addr_t
                                , vlan : vlan_t
                                , l3   : l3_pkt_t}

typedef vlan_t = VLANNone
               | VLAN { pcp : bit<3>
                      , dei : bit<1>
                      , vid : bit<12>}

typedef l3_pkt_t = L3PktIP4   { ip4 : ip4_pkt_t
                              , l4  : l4_pkt_t}
                 | L3PktIP6   { ip6 : ip6_pkt_t
                              , l4  : l4_pkt_t}
                 | L3PktARP   { arp : arp_pkt_t}
                 | L3PktOther { ethertype : bit<16>}

typedef ip4_pkt_t = IP4Pkt { dscp : bit<6>
                           , ecn  : bit<2>
                           , ttl  : bit<8>
                           , frag : bit<13>
                           , mf   : bool
                           , src  : ip4_addr_t
                           , dst  : ip4_addr_t}

typedef ip6_pkt_t = IP6Pkt { dscp  : bit<6>
                           , ecn   : bit<2>
                           , ttl   : bit<8>
                           , frag  : bit<13>
                           , mf    : bool
                           , label : bit<20>
                           , src   : ip6_addr_t
                           , dst   : ip6_addr_t}

typedef arp_op_t = ARPRequest 
                 | ARPReply

typedef arp_pkt_t = ARPPkt { op  : arp_op_t
                           , spa : ip4_addr_t
                           , tpa : ip4_addr_t
                           , sha : mac_addr_t
                           , tha : mac_addr_t}

typedef l4_pkt_t = L4PktTCP   { tcp : tcp_pkt_t}
                 | L4PktUDP   { udp : udp_pkt_t}
                 | L4PktICMP4 { icmp4 : icmp4_pkt_t}
                 | L4PktICMP6 { icmp6 : icmp6_pkt_t}
                 | L4PktOther { protocol : bit<8>}

typedef tcp_pkt_t = TCPPkt { src   : bit<16>
                           , dst   : bit<16>
                           , flags : bit<9> }

typedef udp_pkt_t = UDPPkt { src   : bit<16>
                           , dst   : bit<16> }

typedef icmp4_pkt_t = ICMP4Pkt { type : bit<8>
                               , code : bit<8> }

typedef icmp6_pkt_t = ICMP6Pkt { type : bit<8>
                               , code : bit<8> }

typedef uuid_t = bit<128>
typedef vlan_id_t = bit<12>

table local_network( name: string
                   , primary key (name))

table logical_switch( uuid : uuid_t
                    , name : string
                    , primary key (uuid))

typedef port_type_t = PortRegular  
                    | PortRouter   { rport: port_id_t}
                    | PortLocalnet { network_name: string}
//                    | PortVTEP     { vtep_physical_switch: string
//                                   , vtep_logical_switch: uuid_t}

function isRouterPort(t: port_type_t): bool = 
    match (t) {
        PortRouter{_} -> true,
        _             -> false
    }

function isRegularPort(t: port_type_t): bool = 
    match (t) {
        PortRegular -> true,
        _           -> false
    }

function isLocalnetPort(t: port_type_t): bool = 
    match (t) {
        PortLocalnet{_} -> true,
        _               -> false
    }

typedef nested_port_t = NestedPortNone
                      | NestedPort {parent: string, tag: vlan_id_t}

table logical_port( name      : port_id_t
                  , switch_id : uuid_t
                  , type      : port_type_t
                  , nested    : nested_port_t
                  , enabled   : bool
                  , primary key (name)
                  , foreign key (switch_id)                 references logical_switch(uuid)
                  , foreign key (type.rport)                references logical_router_port(name)
                  , foreign key (type.network_name)         references local_network(name)
//                  , foreign key (type.vtep_physical_switch) references physical_network(name)
//                  , foreign key (type.vtep_logical_switch)  references logical_switch(uuid)
                  , foreign key (nested.parent)             references logical_port(name)
                  , unique (nested.parsw, nested.tag) /* Siblings must have different tags */
                  , check (is_nested(nested) => not is_router(type)))

view parent_port( child_name    : port_id_t
                , child_switch  : uuid_t
                , child_type    : port_type_t
                , parent_name   : port_id_t
                , parent_switch : uuid_t
                , parent_type   : port_type_t
                , parent_nested : nested_port_t
                , check child_type == parent_type
                , check child_switch == parent_switch
                , check parent_nested == NestedPortNone{})

parent_port(cn: port_id_t, cs: uuid_t, ct, pn, ps, pt, pnest) :- logical_port(cn, _, ct, NestedPort{pn, _}, _),
                                                                 logical_port(pn, _, pt, pnest, _)
   
view trunk_port(port: port_id_t)
trunk_port(p) :- logical_port(_, _, _, NestedPort{p, _}, _)

// If a given logical switch has multiple router ports, the Logical_Router_Port rows that 
// they reference must be all on the same Logical_Router (for different subnets).
view logical_switch_router ( switch_id : uuid_t
                           , router_id : uuid_t
                           , unique (switch_id))
logical_switch_router(sw, r) :- logical_port(_, sw, PortRouter{rp}, _, _), logical_router_port(rp, r)

//assume logical_port(p1, sw, PortRouter{rport1}, _, _) and logical_port(p2, sw, PortRouter{rport2}, _, _) and
//       logical_router_port(rport1, lrouter1) and logical_router_port(rport2, lrouter2) 
//       => lrouter1 == lrouter2

// router port cannot be connected to both switch and other router
assume logical_port(p: port_id_t, _, PortRouter{rport}, _, _) => not logical_router_port_peered(rport)

// Disallow >1 layers of nesting
//assume logical_port(_, sw1, _, NestedPort{parsw, _}, _) and logical_port(_, sw2, _, nested2, _) 
//       => sw1 == sw2 and nested2 == NestedPortNone

// This table is populated by ovn-northd, rather than by the CMS plugin as is most of this database
table logical_port_up( port: port_id_t
                     , up  : bool
                     , foreign key (port) references logical_port(name)
                     , unique (port))

// Addresses owned by the logical port.  Each element in the set must take one 
// of the following forms:
//    xx:xx:xx:xx:xx:xx - An Ethernet address owned by the logical 
//    port.  Like a physical Ethernet NIC, a logical port ordinarily 
//    has a single fixed Ethernet address. When  a  OVN logical switch 
//    processes a unicast Ethernet frame whose destination MAC address 
//    is in a logical port’s addresses column, it delivers it only to                     
//    that port, as if a MAC learning process had learned that MAC 
//    address on the port.
//    xx:xx:xx:xx:xx:xx a.b.c.d - This form has all the effects of the 
//    previous form.  It also indicates that the logical port owns the 
//    given IPv4 address. The OVN logical switch uses this information 
//    to synthesize responses to ARP requests without traversing the 
//    physical network.  The OVN logical  router  connected to the 
//    logical switch, if any, uses this information to avoid issuing 
//    ARP requests for logical switch ports.
//    unknown -This indicates that the logical port has an unknown set 
//    of Ethernet addresses.  When an OVN logical switch processes a 
//    unicast Ethernet frame whose destination MAC address is not in 
//    any logical port’s addresses column, it delivers it to the port 
//    (or ports) whose addresses columns include unknown.

typedef port_addr_t = PortAddressUnknown
                    | PortAddressMAC {mac: mac_addr_t}
                    | PortAddressMACIP4 {mac: mac_addr_t, ip: ip4_addr_t}
                    | PortAddressMACIP6 {mac: mac_addr_t, ip: ip6_addr_t}

table logical_port_address( port: port_id_t
                          , addr: port_addr_t
                          , foreign key (port) references logical_port(name))

view logical_port_mac( port: port_id_t, mac: mac_addr_t)
logical_port_mac(p, mac) :- logical_port_address(p, PortAddressMACIP4{mac, _})
logical_port_mac(p, mac) :- logical_port_address(p, PortAddressMACIP6{mac, _})
logical_port_mac(p, mac) :- logical_port_address(p, PortAddressMAC{mac})

// Eth and mac addresses must be unique with logical switch
view logical_switch_mac( switch_id : uuid_t
                       , port      : port_id_t
                       , mac       : mac_addr_t
                       , unique(switch_id, mac))
logical_switch_mac(sw, port, mac) :- logical_port(p, sw, _, _, _), logical_port_mac(p, mac)

view logical_switch_accepts_unknown( switch_id : uuid_t
                                   , port      : port_id_t)
logical_switch_accepts_unknown(sw, p) :- logical_port(p, sw, _, _, _), logical_port_address(p, PortAddressUnknown)

//assume logical_port(p1, sw, _, _, _) and logical_port(p2, sw, _ ,_ ,_) and
//       logical_port_mac(p1, mac) and logical_port_mac(p2, mac) =>
//       p1 == p2

view logical_switch_ip4_addr( switch_id : uuid_t
                            , mac       : mac_addr_t
                            , ip        : ip4_addr_t
                            , unique(switch_id, ip))
logical_switch_ip4_addr(sw, mac, ip) :- logical_port(p, sw, _, _, _), logical_port_address(p, PortAddressMACIP4{mac,ip})

view logical_switch_ip6_addr( switch_id : uuid_t
                            , mac       : mac_addr_t
                            , ip        : ip6_addr_t
                            , unique(switch_id, ip))
logical_switch_ip6_addr(sw, mac, ip) :- logical_port(p, sw, _, _, _), logical_port_address(p, PortAddressMACIP6{mac,ip})

//assume logical_port_address(p1, sw, _, _, _) and logical_port(p2, sw, _ ,_ ,_) and
//       logical_port_address(p1, PortAddressMACIP{mac1, ip}) and logical_port_address(p2, PortAddressMACIP{mac2, ip}) =>
//       p1 == p2 and mac1 == mac2

// port_security: set of strings
// A set of L2 (Ethernet) addresses from which the logical port is 
// allowed to send packets and to which it is allowed to receive 
// packets.  If this column is empty, all addresses are permitted.  
// Logical ports are always allowed to receive packets addressed to 
// multicast and broadcast addresses.
table logical_port_security( port: port_id_t
                           , mac : mac_addr_t
                           , foreign key (port) references logical_port(name))

view logical_port_secured(port: port_id_t)
logical_port_secured(p) :- logical_port_security(p, _)

table logical_router( uuid: uuid_t   
                    , name: port_id_t
                    , default_gw: ip_addr_t
                    , primary key (uuid))

typedef netmask_t = NetMask4 {mask4: ip4_netmask_t}
                  | NetMask6 {mask6: ip6_netmask_t}

typedef ip4_netmask_t = IP4NetMask {ip: ip4_addr_t, mask: bit<6>}
typedef ip6_netmask_t = IP6NetMask {ip: ip6_addr_t, mask: bit<10>}

typedef router_port_peer_t = PeerSwitch
                           | PeerRouter {peer_port: port_id_t}

table logical_router_port( name    : port_id_t
                         , router  : uuid_t
                         , network : netmask_t
                         , mac     : mac_addr_t
                         , enabled : bool
                         , peer    : router_port_peer_t
                         , primary key (name)
                         , foreign key (router) references logical_router(uuid)
                         , foreign key (peer.peer_port) references logical_router_port(name))

view logical_router_port_peered(port: port_id_t)
logical_router_port_peered(p) :- logical_router_port(p, _, _, _, _, PeerRouter{_})

assume logical_router_port(p, _, _, _, _, PeerRouter{peer}) => logical_router_port_peered(peer)
assume logical_router_port(p, _, _, _, _, PeerRouter{peer}) and logical_router_port_peered(peer, _, _, _, _, PeerRouter{ppeer}) 
       => ppeer == p

typedef acl_direction_t = DirToLPort
                        | DirFromLPort

typedef acl_action_t = ActionAllow
                     | ActionAllowRelated
                     | ActionDrop
                     | ActionReject // Not implemented--currently treated as drop

table acl_from ( switch_id : uuid_t
               , port      : port_id_t
               , packet    : Packet
               , action    : acl_action_t 
               , foreign key (switch_id) references logical_switch(uuid)
               , foreign key (port)      references logical_port(name)
               , unique (switch_id, port, direction, packet))

table acl_to   ( switch_id : uuid_t
               , port      : port_id_t
               , from      : port_id_t
               , packet    : Packet
               , action    : acl_action_t 
               , foreign key (switch_id) references logical_switch(uuid)
               , foreign key (port)      references logical_port(name)
               , foreign key (from)      references logical_port(name)
               , unique (switch_id, port, direction, packet))



function sourcePort(name: port_id_t, p:Packet): port_id_t =
    // trunk port?
    if trunk_port(name) {
        filter p.vlan != VLANNone;
        let sname = logical_port.where(_.nested == NestedPort{name, p.vlan.vid}).map(_.name).single();
        p.vlan := VLANNone;
        sname
    } else {
        // drop packets with VLAN tags or multicast Ethernet source addresses
        filter p.vlan == VLANNone;
        name
    }

// opaque type
typedef ct_state_t

typedef ct_flow_state_t = CTNew
                        | CTEstablished
                        | CTRelated
                        | CTInvalid

// externally defined functions
function ct_track_from(inout s: ct_state_t, p: Packet): ct_flow_state_t
function ct_track_to(inout s: ct_state_t, p: Packet): ct_flow_state_t
function ct_commit_from(inout s: ct_state_t, p: Packet): ()
function ct_commit_to(inout s: ct_state_t, p: Packet): ()

state ct_state: map<port_id_t, ct_state_t>

role LogicalPortIn[port: port_id_t where iLogicalPort(port)] = 
    let (sw, enabled) = logical_port.where(_.port == port).map((_.switch_id, _.enabled)).single();
    // drop all packets if port is disabled
    filter enabled;
    // drop multicast packets
    filter ethUnicastAddr(pkt.src);
    let sport = sourcePort(port);
    // port security enabled? - check valid eth.src address
    if logical_port_secured(sport) 
        filter logical_port_security(sport, pkt.src);

    // send to connection tracker
    let cts = ct_track_from(ct_state[sport], pkt);
    // invalid - drop
    filter cts != CTInvalid;
    // established | committed -- pass through
    if cts != CTEstablished and cts != CTRelated {
        // apply ACL
        let action = acl_from.where(_.switch_id == sw and _.port==sport, and _.packet==pkt).single().action;
        match (action) {
            ActionAllow        -> filter true,
            ActionAllowRelated -> ct_commit_from(ct_state[sport], pkt),
            _                  -> filter false
        }
    }
    if ethMulticastAddr(pkt.dst) or ethBroadcastAddr(pkt.dst) {
        // multicast | broadcast -- send to all ports
        fork dport in logical_port(dport, sw, _, _, _))
            deliver(dport, sport)
    } else if knownAddr(sw, pkt.dst) {
        // unicast to known destination
        let dport = logical_switch_mac.where(_.switch_id==sw and _.mac == pkt.dst).single().port;
        deliver(dport, sport)
    } else {
        // otherwise, multicast to all ports that accept packets for unknown destinations
        fork dport in logical_switch_accepts_unknown(sw, dport)
            deliver(dport, sport)
    }

function deliver(port: port_id_t, fromport: port_id_t): () =
    let (sw, nested, enabled) = logical_port.where(_.port == port).map(_.switch_id, _.nested, _.enabled).single();
    // send to connection tracker
    let cts = ct_track_to(ct_state[port], pkt);
    // invalid - drop
    filter cts != CTInvalid;
    // established | committed -- pass through
    if cts != CTEstablished and cts != CTRelated {
        // apply ACL
        let action = acl_to.where(_.switch_id == sw and _.port==port and _.from == fromport and _.packet == pkt).single().action;

        match (action) {
            ActionAllow        -> filter true,
            ActionAllowRelated -> ct_commit_to(ct_state[port], pkt),
            _                  -> filter false
        }
    }
    // always deliver mcast and bcast packets
    if (ethUnicastAddr(pkt.dst)) {
        // port security enabled? - check valid eth.dst address
        if logical_port_secured(port) 
            filter logical_port_security(port, pkt.dst)
    };
    // add VLAN encapsulation for nested ports
    match (nested) {
        NestedPortNone         -> send lportSendOut(port),
        NestedPort{pport, tag} -> {
            pkt.vlan := VLAN{0, 0, tag};
            send lportSendOut(pport)
        }
    }

function lportSendOut(port: port_id_t): () =
    if iLogicalPort(port) {
        send LogicalPortOut[port]
    } else {
        let rport = logical_port.where(_.port==port).single().type.rport;
        send RouterPortIn[rport]
    }

function iLogicalPort(port: port_id_t): bool =
    logical_port(port, _, type, NestedPortNone, _) and (isRegularPort(type) or isLocalnetPort(type))

role LogicalPortOut[port: port_id_t where iLogicalPort(port)] = filter false


/*
Logical Switch Datapaths

Ingress Table 0: Admission Control and Ingress Port Security

Ingress table 0 contains these logical flows:
· Priority 100 flows to drop packets with VLAN tags or multicast 
Ethernet source addresses.
· Priority 50 flows that implement ingress port security for each 
enabled logical port.  For logical ports on which port security is 
enabled, these match the inport and the valid eth.src address(es) and 
advance only those packets to the next flow table.  For logical ports 
on which port security is not enabled, these advance all packets that 
match the inport.

There are no flows for disabled logical ports because the default-drop 
behavior of logical flow tables causes packets that ingress from them 
to be dropped.

Ingress Table 1: from-lport Pre-ACLs

Ingress table 1 prepares flows for possible stateful ACL processing in 
table 2.  It contains a priority-0 flow that simply moves traffic to 
table 2.  If stateful ACLs are used in the logical datapath, a 
priority-100 flow is added that sends IP packets to the connection 
tracker before advancing to table 2.

Ingress table 2: from-lport ACLs

Logical flows in this table closely reproduce those in the ACL table 
in the OVN_Northbound database for the from-lport direction.  allow 
ACLs translate into logical flows with the next; action, allow-related 
ACLs translate into logical flows with the ct_next; action, other ACLs 
translate to drop;.  The priority values from the ACL table are used 
directly.

Ingress  table  2  also  contains  a priority 0 flow with action 
next;, so that ACLs allow packets by default.  If the logical datapath 
has a statetful ACL, the following flows will also be added:

· A priority-1 flow to commit IP traffic to the connection tracker.  
This is needed for the default allow policy because, while the 
initiater’s direction may not have any stateful rules, the server’s 
may and then its return traffic would not be known and marked as 
invalid.

· A priority-65535 flow that allows any traffic that has been 
committed to the connection tracker (i.e., established flows).

· A  priority-65535 flow that allows any traffic that is considered 
related to a committed flow in the connection tracker (e.g., an ICMP 
Port Unreachable from a non-listening UDP port).

· A priority-65535 flow that drops all traffic marked by the 
connection tracker as invalid.

Ingress Table 3: Destination Lookup

This table implements switching behavior.  It contains these logical 
flows:

· A priority-100 flow that outputs all packets with an Ethernet 
broadcast or multicast eth.dst to the MC_FLOOD multicast  group,  
which ovn-northd populates with all enabled logical ports.

· One priority-50 flow that matches each known Ethernet address 
against eth.dst and outputs the packet to the single associated output 
port.

· One  priority-0 fallback flow that matches all packets and outputs 
them to the MC_UNKNOWN multicast group, which ovn-northd populates 
with all enabled logical ports that accept unknown destination 
packets.  As a small optimization, if no logical ports accept unknown 
destination packets, ovn-northd omits this multicast group and logical 
flow.

Egress Table 0: to-lport Pre-ACLs

This is similar to ingress table 1 except for to-lport traffic.

Egress Table 1: to-lport ACLs

This is similar to ingress table 2 except for to-lport ACLs.

Egress Table 2: Egress Port Security

This is similar to the ingress port security logic in ingress table 0, 
but with important differences.  Most obviously, outport and eth.dst 
are checked instead of inport and eth.src.  Second, packets directed 
to broadcast or multicast eth.dst are always accepted instead of being 
subject to the port security rules; this is implemented through a 
priority-100 flow that matches on eth.mcast with action output;.  
Finally, to ensure that even broadcast and multicast packets are not 
delivered to disabled logical ports, a priority-150 flow for each 
disabled logical outport overrides the priority-100 flow with a drop; 
action.

Logical Router Datapaths
Ingress Table 0: L2 Admission Control

This table drops packets that the router shouldn’t see at all based on 
their Ethernet headers.  It contains the following flows:

· Priority-100 flows to drop packets with VLAN tags or multicast 
Ethernet source addresses.

· For each enabled router port P with Ethernet address E, a 
priority-50 flow that matches inport == P && (eth.mcast || eth.dst == 
E), with action next;.

Other packets are implicitly dropped.

Ingress Table 1: IP Input

This table is the core of the logical router datapath functionality.  
It contains the following flows to implement very basic IP host 
functionality.

· L3 admission control: A priority-100 flow drops packets that match 
any of the following:
   · ip4.src[28..31] == 0xe (multicast source)
   · ip4.src == 255.255.255.255 (broadcast source)
   · ip4.src == 127.0.0.0/8 || ip4.dst == 127.0.0.0/8 (localhost source or destination)
   · ip4.src == 0.0.0.0/8 || ip4.dst == 0.0.0.0/8 (zero network source or destination)
   · ip4.src is any IP address owned by the router.
   · ip4.src is the broadcast address of any IP network known to the 
router.
   · ICMP echo reply.  These flows reply to ICMP echo requests 
received for the router’s IP address.  Let A be an IP address or  
broadcast address owned by a router port.  Then, for each A, a 
priority-90 flow matches on ip4.dst == A and icmp4.type == 8 && 
icmp4.code == 0 (ICMP echo request).  These flows use the                   
following actions where, if A is unicast, then S is A, and if A is 
broadcast, S is the router’s IP address in A’s network:

                     ip4.dst = ip4.src;
                     ip4.src = S;
                     ip.ttl = 255;
                     icmp4.type = 0;
                     inport = ""; // Allow sending out inport.
                     next;

Similar flows match on ip4.dst == 255.255.255.255 and each individual 
inport, and use the same actions in which S is a function of inport.

    · ARP reply.  These flows reply to ARP requests for the router’s 
own IP address.  For each router port P that owns IP address A and 
Ethernet address E, a priority-90 flow matches inport == P && arp.tpa 
== A && arp.op == 1 (ARP request) with the following actions:

                     eth.dst = eth.src;
                     eth.src = E;
                     arp.op = 2; // ARP reply.
                     arp.tha = arp.sha;
                     arp.sha = E;
                     arp.tpa = arp.spa;
                     arp.spa = A;
                     outport = P;
                     inport = ""; // Allow sending out inport.
                     output;

    · UDP port unreachable.  Priority-80 flows generate ICMP port 
unreachable messages in reply to UDP datagrams directed to the 
router’s IP address.  The logical router doesn’t accept any UDP 
traffic so it always generates such a reply.

These flows should not match IP fragments with nonzero offset.

Details TBD.  Not yet implemented.

· TCP reset.  Priority-80 flows generate TCP reset messages in reply 
to TCP datagrams directed to the router’s IP address.  The logical 
router doesn’t accept any TCP traffic so it always generates such a 
reply.

These flows should not match IP fragments with nonzero offset.

Details TBD.  Not yet implemented.

· Protocol unreachable.  Priority-70 flows generate ICMP protocol 
unreachable messages in reply to packets directed to the router’s IP 
address on IP protocols other than UDP, TCP, and ICMP.

These flows should not match IP fragments with nonzero offset.

Details TBD.  Not yet implemented.

· Drop other IP traffic to this router.  These flows drop any other 
traffic destined to an IP address of this router that is not already 
handled by one of the flows  above, which amounts to ICMP (other than 
echo requests) and fragments with nonzero offsets.  For each IP 
address A owned by the router, a priority-60 flow matches ip4.dst == A 
and drops the traffic.

The flows above handle all of the traffic that might be directed to 
the router itself.  The following flows (with lower priorities) handle 
the remaining traffic, potentially for forwarding:

· Drop Ethernet local broadcast.  A priority-50 flow with match 
eth.bcast drops traffic destined to the local Ethernet broadcast 
address.  By definition this traffic should not be forwarded.

·  Drop IP multicast.  A priority-50 flow with match ip4.mcast drops 
IP multicast traffic.

· ICMP time exceeded.  For each router port P, whose IP address is A, 
a priority-40 flow with match inport == P && ip.ttl == {0, 1} && 
!ip.later_frag matches packets whose TTL has expired, with the 
following actions to send an ICMP time exceeded reply:

                     icmp4 {
                         icmp4.type = 11; // Time exceeded. 
                         icmp4.code = 0;  // TTL exceeded in transit.
                         ip4.dst = ip4.src;
                         ip4.src = A;
                         ip.ttl = 255;
                         next;
                     };

Not yet implemented.

· TTL  discard.   A  priority-30  flow with match ip.ttl == {0, 1} and 
actions drop; drops other packets whose TTL has expired, that should 
not receive a ICMP error reply (i.e. fragments with nonzero offset).

· Next table.  A priority-0 flows match all packets that aren’t 
already handled and uses actions next; to feed them to the ingress 
table for routing.

Ingress Table 2: IP Routing

A packet that arrives at this table is an IP packet that should be 
routed to the address in ip4.dst.  This table implements IP routing, 
setting reg0 to the next-hop IP address (leaving ip4.dst, the packet’s 
final destination, unchanged) and advances to the next table for ARP 
resolution.

This table contains the following logical flows:

· Routing table. For each route to IPv4 network N with netmask M, a 
logical flow with match ip4.dst == N/M, whose priority is the number 
of 1-bits in M, has the following actions:

                     ip.ttl--;
                     reg0 = G;
                     next;

(Ingress table 1 already verified that ip.ttl--; will not yield a TTL 
exceeded error.)

If the route has a gateway, G is the gateway IP address, otherwise it 
is ip4.dst.

· Destination unreachable.  For each router port P, which owns IP 
address A, a priority-0 logical flow with match in_port == P && 
!ip.later_frag && !icmp has the following actions:

                     icmp4 {
                         icmp4.type = 3; // Destination unreachable. 
                         icmp4.code = 0; // Network unreachable.
                         ip4.dst = ip4.src;
                         ip4.src = A;
                         ip.ttl = 255;
                         next(2);
                     };

(The !icmp check prevents recursion if the destination unreachable 
message itself cannot be routed.)

These flows are omitted if the logical router has a default route, 
that is, a route with netmask 0.0.0.0.

Ingress Table 3: ARP Resolution

Any  packet that reaches this table is an IP packet whose next-hop IP 
address is in reg0.  (ip4.dst is the final destination.)  This table 
resolves the IP address in reg0 into an output port in outport and an 
Ethernet address in eth.dst, using the following flows:

· Known MAC bindings.  For each IP address A whose host is known to 
have Ethernet address HE and reside on router port P with Ethernet 
address  PE,  a  priority-200 flow with match reg0 == A has the 
following actions:

                     eth.src = PE;
                     eth.dst = HE;
                     outport = P;
                     output;

MAC  bindings  can  be  known  statically based on data in the 
OVN_Northbound database.  For router ports connected to logical 
switches, MAC bindings can be known statically from the addresses 
column in the Logical_Port table.  For router ports connected to other 
logical routers, MAC bindings can be known statically from the mac and 
network column in the Logical_Router_Port table.

· Unknown MAC bindings.  For each non-gateway route to IPv4 network N 
with netmask M on router port P that owns IP address A and Ethernet 
address E, a logical flow with match ip4.dst == N/M, whose priority is 
the number of 1-bits in M, has the following actions:

                     arp {
                         eth.dst = ff:ff:ff:ff:ff:ff;
                         eth.src = E;
                         arp.sha = E;
                         arp.tha = 00:00:00:00:00:00;
                         arp.spa = A;
                         arp.tpa = ip4.dst;
                         arp.op = 1;  // ARP request. 
                         outport = P;
                         output;
                     };

TBD: How to install MAC bindings when an ARP response comes back.  
(Implement a "learn" action?)


Not yet implemented.

     Egress Table 0: Delivery

Packets that reach this table are ready for delivery.  It contains 
priority-100 logical flows that match packets on each enabled logical 
router port, with action output;.

*/
/*
source role LogicalPortIn[port: string where iLogicalPort(port) and pkt.srcAddr != bcast_addr] = 
    let (enabled, sw) = logical_port
                      . where(_.p == port)
                      . map((_.sw, _.enabled))
                      . single();
    //let (enabled, sw) = logical_port(port, sw, _, _, enabled).single();
    if not enabled drop;
    let sport: string = sourcePort(port);
    // port security enabled? - check valid eth.src address
    if not logical_port_security(sport, pkt.src) exit;

    match (action) {
        ActionAllow:        skip,
        ActionAllowRelated: ct_commit_from(ct_state[sport], pkt),
        _:                  exit
    }
    forall (dport in logical_port.where(_.sw == sw).map(_.dport))
        deliver(dport, sport)

function where1(relation() ports, port: string): relation =
    forall (port in ports)
  */      

/*
source role LogicalPortIn[port: string where iLogicalPort(port) and pkt.srcAddr != bcast_addr] = 

    let sw, enabled | logical_port(port, sw, _, _, enabled);
    let (enabled, sw) = logical_port
                      . where(_.p == port)
                      . map((_.sw, _.enabled))
                      . single()
                      . where((sw, enabled) -> enabled);
    //let (enabled, sw) = logical_port(port, sw, _, _, enabled).single();
    if (not enabled) drop;
    let sport: string = sourcePort(port);
    // port security enabled? - check valid eth.src address
    if not logical_port_security(sport, pkt.src) exit;

    match (action) {
        ActionAllow:        (),
        ActionAllowRelated: ct_commit_from(ct_state[sport], pkt),
        _:                  drop
    }
    fork dport in logical_port.where(_.sw == sw).map(_.dport)
        deliver(dport, sport)
*/

/*
Linq join syntax:
- c1.join(c2, e1.c1 => k, e2.c2=>k).map(\(e1, e2) => T)
- (c1, c2).join(\(e1, e2) => e1.c1 == e2.c2).map(\(e1, e2) => T)
- c1.selectmany ( e => c2.where(e2 => e == e2) )
- 

*/


rel' = map(rel, f)
rel'(x) :- rel(y) and x = f(y)

rel' = where(rel, f)
rel'(x) :- rel(x) and f(x)

rel' = rel1 * rel2
rel'((xdw,y), f1, ) :- rel1(x) and rel2(y)

rel' = c1.join(c2, f1, f2)
rel'((x,y)) :- c1(x) and c2(y) and f1(x) == f2(y)
