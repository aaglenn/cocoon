(* Liu et al. F10: A Fault-Tolerant Engineered Network *)

typedef struct {
    uint<8> ip3,
    uint<8> ip2,
    uint<8> ip1,
    uint<8> ip0
} IP4

typedef struct {
    uint<48> dstAddr,
    uint<48> srcAddr
} HEth

typedef struct {
    HEth     eth
} Packet

function p(): uint<8>
assume () p() < 8'd128 

function k(): uint<8> = p() + p()

function incmodp(uint<8> v): uint<8> = 
    case {
        (v + 8'd1) < p(): (v + 8'd1);
        default:          (v + 8'd1) - p();
    }

function tree(uint<48> addr): uint<1> = addr[0:0]
function i1(uint<48> addr): uint<8>   = addr[15:8]
function i0(uint<48> addr): uint<8>   = addr[23:16]
function port(uint<48> addr): uint<8> = addr[31:24]

function iL0Port(uint<8> i1, uint<8> i0, uint<8> port): bool = 
    i1 < p() and i0 < p() and port < p()

function goodPacket(Packet p): bool = 
    iL0Port(i1(p.eth.dstAddr), i0(p.eth.dstAddr), port(p.eth.dstAddr))

role L0In[uint<1> tree, uint<8> i1, uint<8> i0, uint<8> port] | iL0Port(i1,i0,port) = 
    if goodPacket(pkt) then
        send L0Out[tree(pkt.eth.dstAddr), i1(pkt.eth.dstAddr), i0(pkt.eth.dstAddr), port(pkt.eth.dstAddr)]

role L0Out[uint<1> tree, uint<8> i1, uint<8> i0, uint<8> port] | iL0Port(i1,i0,port) = filter false

refine L0In {

    function hash(HEth eth): uint<8>
    assume (HEth e) hash(e) < p()

    function l1SwitchUp(uint<1> tree, uint<8> i1, uint<8> r): bool = true

    role L0In[uint<1> tree, uint<8> i1, uint<8> i0, uint<8> port] | iL0Port(i1,i0,port) = 
        (* Validate packets at the edge *)
        if goodPacket(pkt) then {
            if tree(pkt.eth.dstAddr) == tree and i1(pkt.eth.dstAddr) == i1 and i0(pkt.eth.dstAddr) == i0 then {
                if port(pkt.eth.dstAddr) < p() then {
                    send L0Out[tree, i1, i0, port(pkt.eth.dstAddr)]
                }
            } else {
                if l1SwitchUp(tree, i1, hash(pkt.eth)) then
                    send L01Out[tree, i1, i0, hash(pkt.eth)]
                else
                    send L01Out[tree, i1, i0, incmodp(hash(pkt.eth))]
            }
        }
        
    role L01Out[uint<1> tree, uint<8> i1, uint<8> i0, uint<8> port] | iL0Port(i1,i0,port) / goodPacket(pkt) = 
        if l1SwitchUp(tree, i1, port) then
            send L10In[tree, i1, port, i0]

    role L01In[uint<1> tree, uint<8> i1, uint<8> i0, uint<8> port] | iL0Port(i1,i0,port) / goodPacket(pkt) = 
        send L0Out[tree, i1, i0, port(pkt.eth.dstAddr)]

    function iL1Port(uint<8> i1, uint<8> r, uint<8> port): bool = 
        i1 < p() and r < p() and port < p()

    role L10In[uint<1> tree, uint<8> i1, uint<8> r, uint<8> port] | iL1Port(i1,r,port) / goodPacket(pkt) = 
        ?send L10Out[.tree==tree(pkt.eth.dstAddr) and .i1 == i1(pkt.eth.dstAddr) and .r < p() and .port == i0(pkt.eth.dstAddr)]

    role L10Out[uint<1> tree, uint<8> i1, uint<8> r, uint<8> port] | iL1Port(i1,r,port) / goodPacket(pkt) = 
        send L01In[tree, i1, port, r]
}

refine L10In {

    function l2SwitchUp(uint<8> x, uint<8> y): bool = true

    role L10In[uint<1> tree, uint<8> i1, uint<8> r, uint<8> port] | iL1Port(i1,r,port) / goodPacket(pkt) = 
         if tree(pkt.eth.dstAddr) == tree and i1(pkt.eth.dstAddr) == i1 then {
            if i0(pkt.eth.dstAddr) < p() then {
                send L10Out[tree, i1, r, i0(pkt.eth.dstAddr)]
            }
        } else if tree == 1'd0 then {
            if l2SwitchUp(r, hash(pkt.eth)) then
                send L12Out[tree, i1, r, hash(pkt.eth)]
            else
                send L12Out[tree, i1, r, incmodp(hash(pkt.eth))]
        } else {
            if l2SwitchUp(hash(pkt.eth), r) then
                send L12Out[tree, i1, r, hash(pkt.eth)]
            else
                send L12Out[tree, i1, r, incmodp(hash(pkt.eth))]
        }

    role L12Out[uint<1> tree, uint<8> i1, uint<8> r, uint<8> port] | iL1Port(i1,r,port) / goodPacket(pkt) = 
        if tree == 1'd0 then {
             if l2SwitchUp(r, port) then
                send L2In[r, port, i1]           
        } else {
            if l2SwitchUp(port, r) then
                send L2In[port, r, p() + i1]
        }

    function iL2Port(uint<8> x, uint<8> y, uint<8> port): bool = 
        x < p() and y < p() and port < k()

    role L2In[uint<8> x, uint<8> y, uint<8> port] | iL2Port(x,y,port) / goodPacket(pkt) = 
        if tree(pkt.eth.dstAddr) == 1'd0 then {
             if l1SwitchUp(1'd0, i1(pkt.eth.dstAddr), x) then
                send L2Out[x, y, i1(pkt.eth.dstAddr)]
             else 
                send L2Out[x, y, p() + hash(pkt.eth)]
        } else {
             if l1SwitchUp(1'd1, i1(pkt.eth.dstAddr), y) then
                send L2Out[x, y, p() + i1(pkt.eth.dstAddr)]
             else 
                send L2Out[x, y, hash(pkt.eth)]
        }

    role L2Out[uint<8> x, uint<8> y, uint<8> port] | iL2Port(x,y,port) / goodPacket(pkt) = 
        if (port < p()) then {
             if l1SwitchUp(1'd0, port, x) then
                send L12In[1'd0, port, x, y]
        } else {
             if l1SwitchUp(1'd1, port - p(), y) then
                send L12In[1'd1, port - p(), y, x]
        }

    role L12In[uint<1> tree, uint<8> i1, uint<8> r, uint<8> port] | iL1Port(i1,r,port) / goodPacket(pkt) = 
        if (tree == tree(pkt.eth.dstAddr) and i1 == i1(pkt.eth.dstAddr)) then {
            send L10Out[tree, i1, r, i0(pkt.eth.dstAddr)]
        } else {
            send L12Out[tree, i1, r, incmodp(port)]
        }
}

refine {
    function p(): uint<8> = 8'd2
}
