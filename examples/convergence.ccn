(* Secure home network *)

typedef struct {
    uint<8> ip3,
    uint<8> ip2,
    uint<8> ip1,
    uint<8> ip0
} IP4

typedef struct {
    uint<48> dstAddr,
    uint<48> srcAddr
} eth_t

typedef struct {
    bool valid,
    uint<16> oper,
    uint<48> sha,
    uint<32> spa,
    uint<48> tha,
    uint<32> tpa
} arp_t

typedef struct {
    bool valid,
    uint<8> protocol,
    IP4 src,
    IP4 dst
} ip4_t

typedef struct {
    bool     valid,
    uint<24> vni,
    eth_t    eth,
    ip4_t    ip4
} vxlan_t

typedef struct {
    eth_t    eth,
    ip4_t    ip4,
    vxlan_t  vxlan
} Packet

typedef uint<24> VNetId
typedef uint<32> VHostId
typedef struct {
    VHostId vhost,
    uint<8> vport
} VHPortId

(*  TODO: 
    - basic virtualization
    - Broad/multicast
    - Secure router + verified security policy
    - Multiple physical networks
 *)

(* Virtual network topology *)
function iVNet(VNetId id): bool
function iVHost(VHostId id): bool
function iVHostPort(VHPortId port): bool
assume (VHPortId port) iVHostPort(port) => iVHost(port.vhost)

function vHPortVNet(VHPortId port): VNetId

function vHPort2Mac(VHPortId port): uint<48>
function mac2VHPort(VNetId vnet, uint<48> mac): VHPortId
assume (VHPortId port, uint<48> mac, VNetId vnet) (* bijection *)
       iVHostPort(port) => 
           ((vHPortVNet(port) == vnet and vHPort2Mac(port) == mac) == (mac2VHPort(vnet, mac) == port))

role VHostIn[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) = filter false

role VHostOut[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) = 
    (* Deliver to destination MAC within virtual network *)
    let VHPortId vhport = mac2VHPort(vHPortVNet(VHPortId{vhost, port}), pkt.eth.dstAddr);
    if iVHostPort(vhport) then
       send VHostIn[vhport.vhost, vhport.vport]

refine VHostOut {

    (* Physical topology *)

    function iHost(IP4 addr): bool
    function iVSwitchPort(IP4 hst, uint<16> swport): bool
    assume (IP4 hst, uint<16> swport) iVSwitchPort(hst, swport) => iHost(hst)

    function vHostLocation(VHostId vhost): IP4

    function vH2SwLink(VHPortId hport): uint<16>
    function vSw2HLink(IP4 addr, uint<16> swport): VHPortId

    function vSwPortVNet(IP4 addr, uint<16> swport): VNetId =
        vHPortVNet(vSw2HLink(addr, swport))

    assume (VHPortId hport, IP4 ip, uint<16> swport) (* link symmetry *)
           (iVHostPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwLink(hport) == swport) == (iVSwitchPort(ip, swport) and vSw2HLink(ip, swport) == hport)

    role VHostOut[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) =
        send VSwitchIn[vHostLocation(vhost), vH2SwLink(VHPortId{vhost, port})]

    function vxlanEncapsulate(Packet p, VNetId vnet, IP4 src, IP4 dst): Packet =
        Packet{ eth_t{48'd0, 48'd0}
              , ip4_t{true, 8'd17(*UDP*), src, dst}
              , vxlan_t{true, vnet, p.eth, p.ip4}}

    function vxlanDecapsulate(Packet p): Packet =
        Packet{ p.vxlan.eth
              , p.vxlan.ip4
              , vxlan_t{false, 24'd0, eth_t{48'd0, 48'd0}, ip4_t{false, 8'd0, IP4{8'd0, 8'd0, 8'd0, 8'd0}, IP4{8'd0, 8'd0, 8'd0, 8'd0}}}}

    role VSwitchIn[IP4 hst, uint<16> vport] | iVSwitchPort(hst, vport) = 
        (* Destination exists? *)
        let VNetId vnet = vSwPortVNet(hst, vport);
        let VHPortId vhport = mac2VHPort(vnet, pkt.eth.dstAddr);
        if iVHostPort(vhport) then {
            if (vHostLocation(vhport.vhost) == hst) then { 
                (* Local destination -- deliver *)
                send VSwitchOut[hst, vH2SwLink(vhport)]
            } else {
                (* Remote destination -- encapsulate *)
                pkt := vxlanEncapsulate( pkt
                                       , vnet
                                       , hst
                                       , vHostLocation(vhport.vhost));
                send HostOut[hst, 8'd0]
            }
        }
        
    role VSwitchOut[IP4 hst, uint<16> vport] | iVSwitchPort(hst, vport) = 
        let VHPortId vhport = vSw2HLink(hst, vport);
        send VHostIn[vhport.vhost, vhport.vport]

    role HostOut[IP4 hst, uint<8> port] | iHost(hst) and port == 8'd0 = 
        send Fabric[]

    role Fabric[] = 
        if (pkt.ip4.valid and iHost(pkt.ip4.dst)) then
            send HostIn[pkt.ip4.dst, 8'd0]

    role HostIn[IP4 hst, uint<8> port] | iHost(hst) and port == 8'd0 = 
        if pkt.vxlan.valid then {
            (* Decapsulate *)
            let vxlan_t vxlan = pkt.vxlan;
            pkt := vxlanDecapsulate(pkt);
            send VSwitchOut[hst, vH2SwLink(mac2VHPort(vxlan.vni, vxlan.eth.dstAddr))]
        }
}

refine {
    function iVNet(VNetId id): bool = 
        id == 24'd0 or id == 24'd1
    function iVHost(VHostId id): bool = 
        id == 32'd0 or id == 32'd1 or id == 32'd2 or id == 32'd3 or id == 32'd4 or id == 32'd5
    function iVHostPort(VHPortId port): bool = 
        iVHost(port.vhost) and port.vport == 8'd0
    function vHPortVNet(VHPortId port): VNetId = 
        case {
            port.vhost == 32'd0 or port.vhost == 32'd1 or port.vhost == 32'd2 : 24'd0;
            default: 24'd1;
        }
    function vHPort2Mac(VHPortId port): uint<48> = 
        case {
            port.vhost == 32'd0 and port.vport == 8'd0: 48'h020000000001;
            port.vhost == 32'd1 and port.vport == 8'd0: 48'h020000000002;
            port.vhost == 32'd2 and port.vport == 8'd0: 48'h020000000003;
            port.vhost == 32'd3 and port.vport == 8'd0: 48'h020000000004;
            port.vhost == 32'd4 and port.vport == 8'd0: 48'h020000000005;
            port.vhost == 32'd5 and port.vport == 8'd0: 48'h020000000006;
            default: 48'h0;
        }
    function mac2VHPort(VNetId vnet, uint<48> mac): VHPortId = 
        case {
            mac == 48'h020000000001: VHPortId{32'd0, 8'd0};
            mac == 48'h020000000002: VHPortId{32'd1, 8'd0};
            mac == 48'h020000000003: VHPortId{32'd2, 8'd0};
            mac == 48'h020000000004: VHPortId{32'd3, 8'd0};
            mac == 48'h020000000005: VHPortId{32'd4, 8'd0};
            mac == 48'h020000000006: VHPortId{32'd5, 8'd0};
            default: VHPortId{32'd0, 8'd0};
        }

    function iHost(IP4 addr): bool = 
        addr == IP4{8'd10, 8'd0, 8'd0, 8'd1} or addr == IP4{8'd10, 8'd0, 8'd0, 8'd2}

    function iVSwitchPort(IP4 hst, uint<16> swport): bool = 
        (hst == IP4{8'd10, 8'd0, 8'd0, 8'd1} and (swport == 16'd0 or swport == 16'd1 or swport == 16'd2)) or
        (hst == IP4{8'd10, 8'd0, 8'd0, 8'd2} and (swport == 16'd0 or swport == 16'd1 or swport == 16'd2))

    function vHostLocation(VHostId vhost): IP4 = 
        case {
            vhost == 32'd0 or vhost == 32'd2 or vhost == 32'd4: IP4{8'd10, 8'd0, 8'd0, 8'd1};
            default: IP4{8'd10, 8'd0, 8'd0, 8'd2};
        }
    function vH2SwLink(VHPortId hport): uint<16> = 
        case {
            hport == VHPortId{32'd0, 8'd0}: 16'd0;
            hport == VHPortId{32'd1, 8'd0}: 16'd0;
            hport == VHPortId{32'd2, 8'd0}: 16'd1;
            hport == VHPortId{32'd3, 8'd0}: 16'd1;
            hport == VHPortId{32'd4, 8'd0}: 16'd2;
            hport == VHPortId{32'd5, 8'd0}: 16'd2;
            default: 16'd0;
        }
    function vSw2HLink(IP4 addr, uint<16> swport): VHPortId = 
        case {
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd1} and swport == 16'd0: VHPortId{32'd0, 8'd0};
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd1} and swport == 16'd1: VHPortId{32'd2, 8'd0};
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd1} and swport == 16'd2: VHPortId{32'd4, 8'd0};
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd2} and swport == 16'd0: VHPortId{32'd1, 8'd0};
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd2} and swport == 16'd1: VHPortId{32'd3, 8'd0};
            addr == IP4{8'd10, 8'd0, 8'd0, 8'd2} and swport == 16'd2: VHPortId{32'd5, 8'd0};
            default: VHPortId{32'd0, 8'd0};
        }

    role VHost[VHostId vhost] | iVHost(vhost) = filter false
    host VHost( (VHostIn, VHostOut) )

    role VSwitch[IP4 hst] | iHost(hst) = filter false
    switch VSwitch((VSwitchIn, VSwitchOut), (HostIn, HostOut))
}
