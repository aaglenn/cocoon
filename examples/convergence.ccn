(* Secure home network *)

typedef uint<32> IP4

typedef struct {
    uint<48> dstAddr,
    uint<48> srcAddr
} eth_t

typedef struct {
    bool valid,
    uint<16> oper,
    uint<48> sha,
    uint<32> spa,
    uint<48> tha,
    uint<32> tpa
} arp_t

function noarp(): arp_t = arp_t{false, 16'd0, 48'd0, 32'd0, 48'd0, 32'd0}

typedef struct {
    bool valid,
    uint<8> protocol,
    IP4 src,
    IP4 dst
} ip4_t

typedef struct {
    bool     valid,
    uint<24> vni,
    eth_t    eth,
    arp_t    arp,
    ip4_t    ip4
} vxlan_t

function novxlan(): vxlan_t = vxlan_t{false, 24'd0, eth_t{48'd0, 48'd0}, noarp(), ip4_t{false, 8'd0, 32'h0, 32'h0}}

typedef struct {
    eth_t    eth,
    arp_t    arp,
    ip4_t    ip4,
    vxlan_t  vxlan
} Packet

typedef uint<24> VNetId
typedef uint<32> VHostId
typedef struct {
    VHostId vhost,
    uint<8> vport
} VHPortId

(*  TODO: 
    - Verified security policy
    - Service chaining
    - Multiple physical networks
 *)

(* Virtual network topology *)
(*function iVNet(VNetId id): bool*)
function iL2VNet(VNetId id): bool
function iL3VNet(VNetId id): bool
function iVNet(VNetId id): bool = iL3VNet(id) or iL2VNet(id)
assume (VNetId id) not (iL3VNet(id) and iL2VNet(id))

function iVHost(VHostId id): bool
function iVHostPort(VHPortId port): bool
assume (VHPortId port) iVHostPort(port) => iVHost(port.vhost)

function vHPortVNet(VHPortId port): VNetId
assume (VHPortId port) iVHostPort(port) => iVNet(vHPortVNet(port))

function vHPort2Mac(VHPortId port): uint<48>
function mac2VHPort(VNetId vnet, uint<48> mac): VHPortId
assume (VHPortId port, uint<48> mac, VNetId vnet) (* bijection *)
       iVHostPort(port) => 
           ((vHPortVNet(port) == vnet and vHPort2Mac(port) == mac) == (mac2VHPort(vnet, mac) == port))
function bCastMAC(): uint<48> = 48'hffffffffffff
assume (VHPortId vport) bCastMAC() != vHPort2Mac(vport)

function ip2mac(IP4 ip): uint<48>


function arpResponse(Packet p): Packet = 
    Packet{ eth_t { p.arp.tha
                  , p.arp.sha
                  }
          , arp_t { true
                  , 16'd2 (* ARP response *)
                  , ip2mac(p.arp.tpa)
                  , p.arp.tpa
                  , p.arp.sha
                  , p.arp.spa
                  }
          , p.ip4
          , p.vxlan
          }

typedef uint<64> tag_t

function allowedToRead(VHostId hst, tag_t tag): bool

(* Proxy ports can re-taint packets flowing through them.  
   Sensors are a special case of proxies. *)
function iProxyPort(VHPortId port): bool
function taintsWith(VHPortId port, tag_t tag): bool

(* P2P connection allowed *)
function connection(VHPortId from, VHPortId to): bool

function tainted(VHostId hst, tag_t tag): bool
assume (VHPortId port1, VHPortId port2, tag_t tag) 
       (iProxyPort(port1) and taintsWith(port1, tag) and connection(port1, port2)) => tainted(port2.vhost, tag)

assume (VHPortId port1, VHPortId port2, tag_t tag)
       (tainted(port1.vhost, tag) and (not iProxyPort(port1)) and connection(port1, port2)) => tainted(port2.vhost, tag)

(* The main confidentiality property *)
assume (VHostId hst, tag_t tag) tainted(hst, tag) => allowedToRead(hst, tag)


role VHostVIn[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) = filter false

role VHostVOut[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) = 
    let VNetId vnet = vHPortVNet(VHPortId{vhost, port});
    (* Don't allow hosts to lie about their MAC address *)
    if pkt.eth.srcAddr == vHPort2Mac(VHPortId{vhost, port}) then {
        if bCastMAC() == pkt.eth.dstAddr then {
            if iL2VNet(vnet) then {
                pkt.vxlan := novxlan();
                fork (VHPortId vhport | iVHostPort(vhport) and 
                                        vHPortVNet(vhport) == vnet and 
                                        vhport != VHPortId{vhost, port} and 
                                        connection(VHPortId{vhost,port}, vhport)) {
                    send VHostVIn[vhport.vhost, vhport.vport]
                }
            } else if iL3VNet(vnet) and pkt.arp.valid and (pkt.arp.oper == 16'd1 (*ARP Request*)) then {
                pkt := arpResponse(pkt);
                send VHostVIn[vhost, port]
            }
        } else {
            (* Deliver to destination MAC within virtual network *)
            let VHPortId dstvhport = mac2VHPort(vnet, pkt.eth.dstAddr);
            if iVHostPort(dstvhport) and connection(VHPortId{vhost,port}, dstvhport) then {
               pkt.vxlan := novxlan();
               send VHostVIn[dstvhport.vhost, dstvhport.vport]
            }
        }
    }

refine {
    function iHost(IP4 addr): bool

    function iVHostPPort(VHPortId port): bool
    assume (VHPortId port) iVHostPPort(port) => iVHost(port.vhost)

    function v2pPort(VHPortId port): IP4
    function p2vPort(IP4 addr): VHPortId
    assume (VHPortId port, IP4 ip) (iVHostPPort(port) and (ip == v2pPort(port))) => iHost(ip) 
    assume (VHPortId port, IP4 ip) (iVHostPPort(port) and (ip == v2pPort(port))) => (p2vPort(ip) == port)

    role VHostPIn[VHostId vhost, uint<8> port] | iVHostPPort(VHPortId{vhost, port}) = filter false
    role VHostPOut[VHostId vhost, uint<8> port] | iVHostPPort(VHPortId{vhost, port}) = 
        if pkt.vxlan == novxlan() then {
            send VSwitchPlainOut[v2pPort(VHPortId{vhost, port})]
        }

    role VSwitchPlainOut[IP4 hst] | iHost(hst) / not pkt.vxlan.valid = 
        if (pkt.ip4.valid and iHost(pkt.ip4.dst)) then
            send VSwitchPlainIn[pkt.ip4.dst]

    role VSwitchPlainIn[IP4 addr] | iHost(addr) / pkt.vxlan == novxlan() = 
        let VHPortId vport = p2vPort(addr);
        if iVHostPPort(vport) then {
            send VHostPIn[vport.vhost, vport.vport]
        }
}

refine VHostVOut {

    (* Physical topology *)
    function vHostLocation(VHostId vhost): IP4
    assume (VHostId vhost) iVHost(vhost) => iHost(vHostLocation(vhost))
    
    function iVSwitchPort(IP4 hst, uint<16> swport): bool
    assume (IP4 hst, uint<16> swport) iVSwitchPort(hst, swport) => iHost(hst)

    function hHostsVNet(IP4 hst, VNetId vnet): bool
    assume (VHPortId vhport, VNetId vnet, IP4 hst) (vHPortVNet(vhport) == vnet and vHostLocation(vhport.vhost) == hst) => hHostsVNet(hst, vnet) 


    function vH2SwLink(VHPortId hport): uint<16>
    function vSw2HLink(IP4 addr, uint<16> swport): VHPortId

    function vSwPortVNet(IP4 addr, uint<16> swport): VNetId =
        vHPortVNet(vSw2HLink(addr, swport))

    function downTunVnet(): VNetId
    function upTunVnet(): VNetId
    assume (VNetId vnet) iVNet(vnet) => (downTunVnet() != vnet)
    assume (VNetId vnet) iVNet(vnet) => (upTunVnet() != vnet)
    assume () upTunVnet() != downTunVnet()

    (* link symmetry: break it into 5 assertions to help z3 handle quantifiers *)
    (*assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVHostPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwLink(hport) == swport) == ((iVSwitchPort(ip, swport)) and (vSw2HLink(ip, swport) == hport)) *)
    
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVHostPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwLink(hport) == swport) => (iVSwitchPort(ip, swport))
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVHostPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwLink(hport) == swport) => (vSw2HLink(ip, swport) == hport)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPort(ip, swport) and vSw2HLink(ip, swport) == hport) => iVHostPort(hport)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPort(ip, swport) and vSw2HLink(ip, swport) == hport) => (vHostLocation(hport.vhost) == ip)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPort(ip, swport) and vSw2HLink(ip, swport) == hport) => (vH2SwLink(hport) == swport)

    function vxlanEncapsulate(Packet p, VNetId vnet, IP4 src, IP4 dst): Packet =
        Packet{ eth_t{48'd0, 48'd0}
              , noarp()
              , ip4_t{true, 8'd17(*UDP*), src, dst}
              , vxlan_t{true, vnet, p.eth, p.arp, p.ip4}}

    function vxlanDecapsulate(Packet p): Packet =
        Packet{ p.vxlan.eth
              , p.vxlan.arp
              , p.vxlan.ip4
              , novxlan()}
 
    role VHostVOut[VHostId vhost, uint<8> port] | iVHostPort(VHPortId{vhost, port}) =
        send VSwitchIn[vHostLocation(vhost), vH2SwLink(VHPortId{vhost, port})]
   
    role VSwitchIn[IP4 hst, uint<16> vport] | iVSwitchPort(hst, vport) = 
        if pkt.eth.srcAddr == vHPort2Mac(vSw2HLink(hst, vport)) then {
            (* Destination exists? *)
            let VNetId vnet = vSwPortVNet(hst, vport);
            if bCastMAC() == pkt.eth.dstAddr then {
                if iL2VNet(vnet) then {
                    fork(IP4 ip | iHost(ip) and hHostsVNet(ip, vnet)) {
                        if ip == hst then {
                            fork(VHPortId vhport | iVHostPort(vhport) and 
                                                   vHPortVNet(vhport) == vnet and 
                                                   vHostLocation(vhport.vhost) == hst and 
                                                   vH2SwLink(vhport) != vport and
                                                   connection(vSw2HLink(hst, vport), vhport)) {
                                pkt.vxlan := novxlan();
                                send VSwitchOut[hst, vH2SwLink(vhport)]
                            }
                        } else {
                            pkt := vxlanEncapsulate( pkt
                                                   , vnet
                                                   , hst
                                                   , ip);
                            send VSwitchVXLANOut[hst]
                        }
                    }
                } else if iL3VNet(vnet) and pkt.arp.valid and (pkt.arp.oper == 16'd1 (*ARP Request*)) then {
                    pkt := arpResponse(pkt);
                    send VSwitchOut[hst, vport]
                }
            } else {
                let VHPortId to_vhport = mac2VHPort(vnet, pkt.eth.dstAddr);
                if iVHostPort(to_vhport) and connection(vSw2HLink(hst, vport), to_vhport) then {
                    if (vHostLocation(to_vhport.vhost) == hst) then { 
                        (* Local destination -- deliver *)
                        pkt.vxlan := novxlan();
                        send VSwitchOut[hst, vH2SwLink(to_vhport)]
                    } else {
                        (* Remote destination -- encapsulate *)
                        pkt := vxlanEncapsulate( pkt
                                               , vnet
                                               , hst
                                               , vHostLocation(to_vhport.vhost));
                        send VSwitchVXLANOut[hst]

                    }
                }
            }
        }
        
    role VSwitchOut[IP4 hst, uint<16> vport] | iVSwitchPort(hst, vport) = 
        let VHPortId vhport = vSw2HLink(hst, vport);
        send VHostVIn[vhport.vhost, vhport.vport]

    role VSwitchVXLANOut[IP4 hst] | iHost(hst) / pkt.vxlan.valid and pkt.vxlan.vni != upTunVnet() and pkt.vxlan.vni != downTunVnet() = 
        if (pkt.ip4.valid and iHost(pkt.ip4.dst)) then
            send VSwitchVXLANIn[pkt.ip4.dst]

    role VSwitchVXLANIn[IP4 hst] | iHost(hst) = 
        if pkt.vxlan.valid then {
            (* Decapsulate *)
            let vxlan_t vxlan = pkt.vxlan;
            pkt := vxlanDecapsulate(pkt);
            if pkt.eth.dstAddr == bCastMAC() then {
                fork(VHPortId vhport | iVHostPort(vhport) and 
                                       vHPortVNet(vhport) == vxlan.vni and 
                                       vHostLocation(vhport.vhost) == hst and 
                                       connection(mac2VHPort(vxlan.vni, pkt.eth.srcAddr), vhport)) {
                    send VSwitchOut[hst, vH2SwLink(vhport)]
                }
            } else {
                send VSwitchOut[hst, vH2SwLink(mac2VHPort(vxlan.vni, vxlan.eth.dstAddr))]
            }
        }
}

refine VHostPOut, VSwitchPlainIn {

    function iVSwitchPPort(IP4 hst, uint<16> swport): bool
    assume (IP4 hst, uint<16> swport) iVSwitchPPort(hst, swport) => iHost(hst)

    function vH2SwPLink(VHPortId hport): uint<16>
    function vSw2HPLink(IP4 addr, uint<16> swport): VHPortId

    (* link symmetry: break it into 5 assertions *)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVHostPPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwPLink(hport) == swport) => (iVSwitchPPort(ip, swport))
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVHostPPort(hport) and vHostLocation(hport.vhost) == ip and vH2SwPLink(hport) == swport) => (vSw2HPLink(ip, swport) == hport)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPPort(ip, swport) and vSw2HPLink(ip, swport) == hport) => iVHostPPort(hport)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPPort(ip, swport) and vSw2HPLink(ip, swport) == hport) => (vHostLocation(hport.vhost) == ip)
    assume (VHPortId hport, IP4 ip, uint<16> swport) 
           (iVSwitchPPort(ip, swport) and vSw2HPLink(ip, swport) == hport) => (vH2SwPLink(hport) == swport)

    role VHostPOut[VHostId vhost, uint<8> port] | iVHostPPort(VHPortId{vhost, port}) = 
        send VSwitchPIn[vHostLocation(vhost), vH2SwPLink(VHPortId{vhost, port})]

    role VSwitchPIn[IP4 hst, uint<16> vport] | iVSwitchPPort(hst, vport) =
        let IP4 dsthost = v2pPort(vSw2HPLink(hst, vport));
        if pkt.vxlan == novxlan() then {
            if (dsthost == hst)(* port on same host *) then {
                send VSwitchPlainOut[hst]
            } else {
                pkt := vxlanEncapsulate( pkt
                                       , downTunVnet()
                                       , hst
                                       , dsthost);
                send VSwitchTunOut[hst]
            }
        }

    role VSwitchPOut[IP4 hst, uint<16> vport] | iVSwitchPPort(hst, vport) =
        let VHPortId vhport = vSw2HPLink(hst, vport);
        send VHostPIn[vhport.vhost, vhport.vport]

    role VSwitchTunOut[IP4 hst] | iHost(hst) / pkt.vxlan.valid and (pkt.vxlan.vni == upTunVnet() or pkt.vxlan.vni == downTunVnet()) = 
        if (pkt.ip4.valid and iHost(pkt.ip4.dst)) then
            send VSwitchTunIn[pkt.ip4.dst]

    role VSwitchTunIn[IP4 hst] | iHost(hst) / pkt.vxlan.valid = 
        if pkt.vxlan.vni == downTunVnet() then {
            pkt := vxlanDecapsulate(pkt);
            send VSwitchPlainOut[hst]
        } else {
            let VHPortId vport = p2vPort(pkt.ip4.src);
            if  iVHostPPort(vport) then {
                pkt := vxlanDecapsulate(pkt);
                send VSwitchPOut[hst, vH2SwPLink(vport)]           
            }
        }

    role VSwitchPlainIn[IP4 addr] | iHost(addr) / pkt.vxlan == novxlan() = 
        let VHPortId vport = p2vPort(addr);
        if iVHostPPort(vport) then {
            let IP4 dsthost = vHostLocation(vport.vhost);
            if dsthost == addr then {
                send VSwitchPOut[addr, vH2SwPLink(vport)]
            } else {
                pkt := vxlanEncapsulate( pkt
                                       , upTunVnet()
                                       , addr
                                       , dsthost);
                send VSwitchTunOut[addr]
            }
        }
}

refine VSwitchTunOut, VSwitchVXLANOut, VSwitchPlainOut{

    role VSwitchTunOut[IP4 hst] | iHost(hst) / pkt.vxlan.valid and (pkt.vxlan.vni == upTunVnet() or pkt.vxlan.vni == downTunVnet()) = 
        send HostOut[hst]

    role VSwitchVXLANOut[IP4 hst] | iHost(hst) / pkt.vxlan.valid and pkt.vxlan.vni != upTunVnet() and pkt.vxlan.vni != downTunVnet() = 
        send HostOut[hst]

    role VSwitchPlainOut[IP4 hst] | iHost(hst) / not pkt.vxlan.valid = 
        send HostOut[hst]

    role HostOut[IP4 hst] | iHost(hst) = 
        if (pkt.ip4.valid and iHost(pkt.ip4.dst)) then
            send HostIn[pkt.ip4.dst]

    role HostIn[IP4 hst] | iHost(hst) = 
        if pkt.vxlan.valid then {
           if pkt.vxlan.vni == upTunVnet() or pkt.vxlan.vni == downTunVnet() then {
                send VSwitchTunIn[hst]
           } else {
                send VSwitchVXLANIn[hst]
           }
        } else {
           send VSwitchPlainIn[hst]
        }
}

refine {
    function iL2VNet(VNetId id): bool = id == 24'd0
    function iL3VNet(VNetId id): bool = id == 24'd1
    function iVHost(VHostId id): bool = 
        id == 32'd0 or id == 32'd1 or id == 32'd2 or id == 32'd3 or id == 32'd4 or id == 32'd5
    function iVHostPort(VHPortId port): bool = 
        iVHost(port.vhost) and port.vport == 8'd0
    function vHPortVNet(VHPortId port): VNetId = 
        case {
            port.vhost == 32'd0 or port.vhost == 32'd1 or port.vhost == 32'd2 : 24'd0;
            default: 24'd1;
        }
    function vHPort2Mac(VHPortId port): uint<48> = 
        case {
            port.vhost == 32'd0 and port.vport == 8'd0: 48'h020000000001;
            port.vhost == 32'd1 and port.vport == 8'd0: 48'h020000000002;
            port.vhost == 32'd2 and port.vport == 8'd0: 48'h020000000003;
            port.vhost == 32'd3 and port.vport == 8'd0: 48'h020000000004;
            port.vhost == 32'd4 and port.vport == 8'd0: 48'h020000000005;
            port.vhost == 32'd5 and port.vport == 8'd0: 48'h020000000006;
            default: 48'h0;
        }
    function mac2VHPort(VNetId vnet, uint<48> mac): VHPortId = 
        case {
            vnet == 24'd0 and mac == 48'h020000000001: VHPortId{32'd0, 8'd0};
            vnet == 24'd0 and mac == 48'h020000000002: VHPortId{32'd1, 8'd0};
            vnet == 24'd0 and mac == 48'h020000000003: VHPortId{32'd2, 8'd0};
            vnet == 24'd1 and mac == 48'h020000000004: VHPortId{32'd3, 8'd0};
            vnet == 24'd1 and mac == 48'h020000000005: VHPortId{32'd4, 8'd0};
            vnet == 24'd1 and mac == 48'h020000000006: VHPortId{32'd5, 8'd0};
            default: VHPortId{32'hffffffff, 8'hff};
        }

    function iHost(IP4 addr): bool = 
        addr == 32'h10000001 or addr == 32'h10000002

    function iVSwitchPort(IP4 hst, uint<16> swport): bool = 
        (hst == 32'h10000001 and (swport == 16'd0 or swport == 16'd1 or swport == 16'd2)) or
        (hst == 32'h10000002 and (swport == 16'd0 or swport == 16'd1 or swport == 16'd2))

    function vHostLocation(VHostId vhost): IP4 = 
        case {
            vhost == 32'd0 or vhost == 32'd2 or vhost == 32'd4: 32'h10000001;
            default: 32'h10000002;
        }
    function vH2SwLink(VHPortId hport): uint<16> = 
        case {
            hport == VHPortId{32'd0, 8'd0}: 16'd0;
            hport == VHPortId{32'd1, 8'd0}: 16'd0;
            hport == VHPortId{32'd2, 8'd0}: 16'd1;
            hport == VHPortId{32'd3, 8'd0}: 16'd1;
            hport == VHPortId{32'd4, 8'd0}: 16'd2;
            hport == VHPortId{32'd5, 8'd0}: 16'd2;
            default: 16'd0;
        }
    function vSw2HLink(IP4 addr, uint<16> swport): VHPortId = 
        case {
            addr == 32'h10000001 and swport == 16'd0: VHPortId{32'd0, 8'd0};
            addr == 32'h10000001 and swport == 16'd1: VHPortId{32'd2, 8'd0};
            addr == 32'h10000001 and swport == 16'd2: VHPortId{32'd4, 8'd0};
            addr == 32'h10000002 and swport == 16'd0: VHPortId{32'd1, 8'd0};
            addr == 32'h10000002 and swport == 16'd1: VHPortId{32'd3, 8'd0};
            addr == 32'h10000002 and swport == 16'd2: VHPortId{32'd5, 8'd0};
            default: VHPortId{32'd0, 8'd0};
        }

    function iVHostPPort(VHPortId port): bool = false
    function iVSwitchPPort(IP4 hst, uint<16> swport):bool = false 

(*
    role VHost[VHostId vhost] | iVHost(vhost) = filter false
    host VHost( (VHostVIn, VHostVOut) )

    role VSwitch[IP4 hst] | iHost(hst) = filter false
    switch VSwitch((VSwitchIn, VSwitchOut), (VSwitchVXLANIn, VSwitchVXLANOut)) *)
}
